# Java 自动类型提升

> 原文:[https://codescracker . com/Java/Java-automatic-type-promotion . htm](https://codescracker.com/java/java-automatic-type-promotion.htm)

除了赋值之外，表达式中还有一个地方可能发生某种类型的转换。想知道为什么，考虑一下这个。在表达式中，中间值所需的精度有时会超过操作数的范围。例如，尝试以下表达式:

```
byte a = 40;
byte b = 50;
byte c = 100;
int d = a * b / c;
```

中间项的输出， **a * b** 很容易超出其任一**字节**操作数的范围。

为了处理这种类型的问题，Java 在评估表达式 时，会自动将每个**字节、短整型**或**字符**操作数提升为**整型**。这意味着子表达式 **a*b** 是使用整数而不是字节来执行的。因此，中间 表达式 **50 * 40** 的结果 2000 是合法的，尽管 **a** 和 **b** 都被指定为类型**字节**。

尽管自动提升非常有用，但它们也会导致令人困惑的编译时错误。例如，这段看似正确的代码会导致一个问题:

```
byte b = 50;
b = b * 2;      // Error! Can't assign an int to a byte!
```

代码试图将绝对有效的**字节**值 **50*2** 存储回**字节**变量。但是，因为在计算表达式时， 操作数被自动提升为 **int** ，所以结果也被提升为 **int** 。 因此，表达式的结果现在是类型 **int** ，如果不使用强制转换，它不能被赋值给一个**字节**。 即使在这种情况下，被赋值的值仍然适合目标类型，也是如此。

如果您理解溢出的影响，您应该使用显式强制转换，例如

```
byte b = 50;
b = (byte) (b * 2);
```

从而得出正确的值 100。

[Java 在线测试](/exam/showtest.php?subid=1)

* * *

* * *