# Java 内置注释

> 原文：<https://codescracker.com/java/java-built-in-annotations.htm>

Java 定义了许多内置注释。其中大多数是专用的，但有九个是通用的。其中四个是从 **java.lang.annotation 导入的:@Retention、@Documented、@Target** 和 **Inherited** 。五、 **@Override、@Deprecated、@FunctionInterface、@SafeVarargs** 、 和 **@SuppressWarnings** ，包含在 **java.lang** 中。

下面我们就来逐一讨论这些内置注释。

## @保留

**@Retention** 被设计为仅用作另一个注释的注释。这指定了保留策略。

## @已记录

**@已记录的**注释是一个标记接口，它告诉工具，一个注释将被记录。它被设计成仅作为注释声明的注释使用 。

## @目标

**@Target** 注释指定了注释可以应用到的项目类型。它被设计成只能作为另一个注释的 注释。

**@Target** 只接受一个参数，它是 **ElementType** 枚举的常量数组。这个参数决定了可以应用注释的声明类型 。此处(此表中)显示了常量及其对应的 声明类型:

| 目标常数 | 注释可以应用于 |
| 注释 _ 类型 | 另一个注释 |
| 构造器 | 构造器 |
| 领域 | 田 |
| 局部变量 | 局部变量 |
| 方法 | 方法 |
| 包裹 | 包裹 |
| 参数 | 参数 |
| 类型 | 类、接口或枚举 |
| 类型参数 | 类型参数(由 JDK 8 添加) |
| 类型 _ 用途 | 类型使用(由 JDK 8 增加) |

您可以在一个 **@Target** 注释中指定这些值中的一个或多个。要指定多个值，必须在一个用 大括号分隔的列表中指定它们。例如，要指定一个注释只应用于字段和局部变量，您可以使用这个 **@Target** 注释:

```
@Target( { ElementType.FIELD, ElementType.LOCAL_VARIABLE } )
```

如果不使用 **@Target** ，那么除了类型参数，注释可以用在任何声明上。因此， 显式地指定一个或多个目标通常是个好主意，这样可以清楚地表明注释的预期用途。

## @继承

继承的是一个标记注释，只能在另一个注释声明中使用。此外，它只影响将在类声明中使用的注释 。

**@Inherited** 导致超类的注释被子类继承。因此，当向子类发出对特定注释的请求 时，如果该注释不在子类中，则随后检查其超类。如果该注释出现在超类 中，并且用**@继承的**进行了注释，那么该注释将被返回。

## @覆盖

**@Override** 是一个只能在方法上使用的标记注释。

用 **@Override** 注释的方法必须覆盖超类中的方法。否则，将会产生编译时错误。 它用于确保超类方法实际上被覆盖，而不是简单地重载。

## @已弃用

**@Deprecated** 是一个标记注释。它表明一个声明是完全的，并已被一个新的形式所取代。

## @功能界面

**@FunctionInterface** 是 JDK 8 增加的标记注释，设计用于界面上。它表明一个 注释的接口是一个功能接口。

一个*函数接口*是一个只包含一个抽象方法的接口。λ 表达式使用函数接口。如果注释接口不是函数接口，将会产生编译错误。

理解 **@FunctionInterface** 并不是创建功能接口所必需的，这一点很重要。根据定义，任何只有一个抽象方法的接口都是函数接口。因此， **@FunctionInterface** 纯粹是信息性的。

## @SafeVarargs

**@SafeVarargs** 是一个可以应用于方法和构造函数的标记注释。它表示没有与 varargs 参数相关联的不安全动作 发生。它用于禁止在其他安全代码上出现未经检查的警告，因为它引用了不可重验证的 varargs 类型 和参数化数组实例化。本质上，不可具体化的类型是泛型类型。它必须只应用于 varargs 方法或者是**静态**或者**最终**的 构造函数。

## @ SuppressWarnings

**@SuppressWarnings** 指定编译器可能发出的一个或多个警告将被抑制。对 抑制的警告以字符串形式通过名称指定。

[Java 在线测试](/exam/showtest.php?subid=1)

* * *

* * *