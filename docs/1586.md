# C++类型转换和类型转换

> 原文:[https://codescracker.com/cpp/cpp-expressions.htm](https://codescracker.com/cpp/cpp-expressions.htm)

## 类型变换

将一种预定义类型转换为另一种预定义类型的过程称为类型转换。当不同类型的常量和变量混合在一个表达式中时，它们被转换为相同的类型。当一种类型的变量与另一种类型的变量混合时，就会发生类型转换。C++有助于将类型转换成以下两种形式:

*   隐式类型转换
*   显式类型转换

## 隐式类型转换

隐式类型转换是由编译器在没有程序员干预的情况下执行的转换。每当不同的数据类型混合在一个表达式(混合模式表达式)中时，通常应用隐式转换，以便不丢失信息。赋值右侧(表达式侧)的值被转换为左侧(目标变量)的类型。

因此，赋值的右边和左边的类型应该是兼容的，这样才能进行类型转换。兼容的数据类型是数学数据类型，即 char、int、float、double。例如，下面的语句:

```
ch = x ;     (where ch is char and x is int)
```

将 x 的值(即整数到位)转换为字符 ch。假设字长为 16 位(2 个字节)，整数变量 x 的左高位被循环，剩下 ch 的低位为 8 位。比方说，如果 x 的值为 1417(其二进制等价值为 0000010110001001)，ch 将具有较低的 8 位，即 10001001，导致信息丢失。

C++编译器将所有操作数转换为最大操作数的类型，这称为类型提升。这是逐个操作完成的，如下面的类型转换算法所述:

*   如果其中一个操作数是 long double 类型，则另一个操作数被转换为 long double 类型。
*   否则，如果其中一个操作数是 double 类型，另一个将被转换为 double。
*   否则，如果其中一个操作数是 float，则另一个操作数被转换为 float。
*   否则，整数提升将在两个操作数上执行。整数提升的过程描述如下:
    一个 char，一个 short int，一个 enumerator 或者一个 int(在它们有符号和无符号的变种中)都可以作为整数类型使用。 如果一个 int 可以表示原类型的所有值，则该值转换为 int；否则，它将被转换为无符号整数。 这个过程叫做积分提升。
*   然后，如果其中一个操作数是无符号长整型，另一个将被转换为无符号长整型。
*   否则，如果一个操作数是 long int，另一个是 unsigned int，那么如果一个 long int 可以表示一个 unsigned int 的所有值，那么这个 unsigned int 就转换成 long int；否则，两个操作数都被转换为无符号长整型。
*   否则，如果其中一个操作数是 long，另一个将被转换为 long。
*   否则，如果一个操作数是无符号的，另一个将被转换为无符号的。
*   否则，两个操作数都是 int。

当从整数转换为字符以及从长整数转换为整数时，适当数量的高阶位(取决于目标类型的大小)将被移除。在许多环境中，这意味着从整数转换为字符时会丢失 8 位，从长整数转换为整数时会丢失 16 位。

下表汇总了分配类型转换:

<caption>Common Type Conversion (assuming a 16-bit word)</caption>
| 目标类型 | 表达式类型 | 可能的信息丢失 |
| 有符号字符 | 茶 | 如果值> 127，目标为负 |
| 茶 | 短整型 | 高阶 8 位 |
| 茶 | （同 Internationalorganizations）国际组织 | 高阶 8 位 |
| 茶 | 长整型 | 高阶 8 位 |
| （同 Internationalorganizations）国际组织 | 长整型 | 高阶 16 位 |
| （同 Internationalorganizations）国际组织 | 漂浮物 | 小数部分以及可能更多 |
| 漂浮物 | 两倍 | 精度，结果四舍五入 |
| 两倍 | 长双份 | 精度，结果四舍五入 |

**记住** -当从较小的类型转换为较长的类型时，例如，从 int 转换为 float 或从 float 转换为 double，不会丢失信息。 它也没有增加任何精确性或准确性。这些类型的转换只改变值的表示形式。

## 显式类型转换-类型转换

操作数到特定类型的显式转换称为类型转换。显式类型转换是用户定义的，它强制表达式为特定类型。这是在 C++中执行类型转换的一般形式

```
(type) expression
```

其中 type 是要进行转换的有效 C++数据类型。例如，要确保表达式(x + y/2)的计算结果为 float 类型，请将其写成:

```
(float) (x + y/2)
```

从上面的语句中可以看出，右侧的结果类型可以使用类型转换运算符()进行显式转换。例如，下面表达式的结果类型是 double。

```
int i, j;
float f, result;
double d;
result = (i/j) + (f/d) - (f+i);
```

如果你想把表达式的类型端显式地转换为浮点型，可以如下所示来完成:

```
result = (float) ( (i/j) + (f/d) - (f+i));
```

强制转换通常被认为是运算符。作为一个运算符，强制转换是一元的，并且与任何其他一元运算符具有相同的优先级。这里有一个例子

```
/* C++ Type Conversion and Type Casting */

#include<iostream.h>
#include<conio.h>
void main()
{
   clrscr();
   float res;
   float f1=15.5, f2=2;
   res = (int)f1/(int)f2;
   cout<<res<<endl;
   res = (int)(f1/f2);
   cout<<res<<endl;
   res = f1/f2;
   cout<<res;
   getch();
}
```

下面是上述 C++程序的运行示例:

![c++ type conversion casting](../Images/afd94330c29d498268eaf3f148147138.png)

[C++在线测试](/exam/showtest.php?subid=3)

* * *

* * *